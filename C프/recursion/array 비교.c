#include <stdio.h>


//equal_array(a, b, n)에서 n이 점점 줄어들면서 호출됩니다. 이때 n-1을 사용하여 배열의 마지막 요소부터 비교하기 시작합니다.
//예를 들어, equal_array(a, b, 5)가 호출되면, 첫 번째 비교는 a[4]와 b[4](배열의 5번째 요소)입니다. 
//그 다음에 equal_array(a, b, 4)를 호출하여 a[3]와 b[3]를 비교하는 식입니다.
int equal_array(int a[],int b[], int n){ //사용할 모든 변수들 다 적어야함
    if(n==0){
      /*
      n이 0이라는 것은 비교할 요소가 없음을 의미합니다. 
      즉, 배열이 비어있거나, 재귀 호출이 끝나면서 모든 요소가 같음을 확인했음을 나타냅니다. 
      이 경우 1을 반환하여 두 배열이 같음을 알립니다.
      */
        return 1;
    }else{
        if(a[n-1]!=b[n-1]){
          /*
          배열의 마지막 요소를 비교합니다. 
          a[n-1]는 배열 a의 n-1번째 인덱스의 요소, b[n-1]는 배열 b의 n-1번째 인덱스의 요소입니다.
          두 요소가 다르면, 즉 a[n-1]과 b[n-1]이 같지 않다면, 0을 반환하여 두 배열이 같지 않음을 표시합니다.
          이렇게 해주는게 이건 for문이랑 달라서 끝에서부터 계산하기가 훨 용이해서.
          */
            return 0;
        }else{
            return equal_array(a, b, n-1);
          /*
          현재 요소가 같다면, 다음 요소를 비교하기 위해 n을 1 줄여서 equal_array 함수를 다시 호출합니다. 
          이렇게 하면 다음 인덱스(즉, n-2)의 요소를 비교하게 됩니다.
          */
        }
    }
}

int main(){
    int a[5]={1, 3, 5, 7, 9};
    int b[5]={1, 3, 5, 7, 8};
    int length = sizeof(a) / sizeof(a[0]);
    
    if(equal_array(a, b, length)){
        printf("배열이 같습니다.\n");
    }else{
        printf("배열이 다릅니다.\n");
    }
    
return 0;
}
